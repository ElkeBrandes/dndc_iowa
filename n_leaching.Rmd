---
title: "Modelled NO3 leaching in Iowa from row cropped and switchgrass fields"
author: "Elke Brandes"
date: "Tuesday, November 01, 2016"
output: html_document
---
This paper describes the data analysis of NO3 leaching results in Iowa. The initial data are the DNDC-outputs from Gabe McNunn on a clu-mapunit scale. I have performed the first analysis steps in the PostgreSQL database and access the resulting tables with the code below (using `dplyr`).

### Connect to the PostgreSQL datbase###
With dplyr:
```{r connect, message=FALSE, }
library('dplyr')

pw <- {
  "5QUXJHTbxj"
}
isuag_db <- src_postgres(dbname = 'isuag',
                           host = 'isu-ag-db.agsolver.com',
                           port = 5432,
                           user = 'isuag',
                           password = pw)

```
With RPostgreSQL:
```{r, message=FALSE}
# install.packages("RPostgreSQL")
require("RPostgreSQL")
pw <- {
  "5QUXJHTbxj"
}
 
# loads the PostgreSQL driver
drv <- dbDriver("PostgreSQL")
# creates a connection to the postgres database
# note that "con" will be used later in each connection to the database
con <- dbConnect(drv, dbname = "isuag",
                 host = "isu-ag-db.agsolver.com", port = 5432,
                 user = "isuag", password = pw)
```

##1. Distributions of NO3 leaching in Iowa, from row cropped and switchgrass fields##

Connect to the isuag database and load tables that contain the rounded average NO3 leaching values (in kg/ha) for the **four scenarios**:

1. Status quo (row cropped areas in corn or soybean as is from 2012-2015)
2. Switchgrass low yield (all areas that were continuously in corn/soy from 2012-2015 were planted to switchgrass in 2006 for 10 years, assuming switchgrass yield is 7000 kg/ha)
3. Switchgrass medium yield (assuming a yield of 10000 kg/ha)
4. Switchgrass high yield (assuming a yield of 12500 kg/ha)

The leaching values and respective patch areas were aggregated to the same leaching values, and for each scenario, one table was created.


Use the dplyr PostgreSQL handle into the database and create a data frame:
```{r fetch_distr}

cgsb_leach <-tbl(isuag_db, "06_cgsb_ave_no3_leach_rounded_aggr")  %>%
  as.data.frame()
swg_low <-tbl(isuag_db, "06_swg_7500_ave_no3_leach_rounded_aggr")  %>%
  as.data.frame()
swg_med <-tbl(isuag_db, "06_swg_10000_ave_no3_leach_rounded_aggr")  %>%
  as.data.frame()
swg_hi <-tbl(isuag_db, "06_swg_12500_ave_no3_leach_rounded_aggr")  %>%
  as.data.frame()
```
I can run some test here (to be added):
```{r test_distr}
# send a query through dplyr
query = "SELECT SUM(area_ha) FROM \"06_cgsb_ave_no3_leach_rounded_aggr\" WHERE ave_no3_leach_cgsb_round > 60"
sum = tbl(isuag_db, sql(query))
sum
```

Create a list of data frames:
```{r list}
data_list <- list(cgsb_leach, swg_low, swg_med, swg_hi)
str(data_list[[1]])
```
Packages needed for the plots:
```{r ggplot, message=FALSE}
library("ggplot2")
library("gridGraphics") # needed for the function unit
```
I am using a modified theme for ggplot that has a black border and white background:
```{r theme}
theme_b_border <- function (base_size = 12, base_family = "") 
{
  theme_grey(base_size = base_size, base_family = base_family) %+replace% 
    theme(
      axis.text = element_text(size = rel(0.8), margin = margin(r=10)), #margin 
      axis.ticks = element_line(colour = "black"),
      axis.ticks.length = unit(0.15, "cm"),
      legend.key = element_rect(colour = NA), panel.background = element_rect(fill = "white", 
      colour = NA), panel.border = element_rect(fill = NA, 
      colour = "black"), panel.grid.major = element_line(colour = NA, 
      size = 0.2), panel.grid.minor = element_line(colour = NA, 
      size = 0.5), strip.background = element_rect(fill = "grey80", 
      colour = "grey50", size = 0.2))
}
```

Prepare a data frame to be used for the facet plot:
```{r data}
scenario <- c(rep("cgsb", sum(sapply(data_list[1],nrow))), rep("swg_low", sum(sapply(data_list[2],nrow))), rep("swg_med", sum(sapply(data_list[3],nrow))), rep("swg_hi", sum(sapply(data_list[4],nrow)))) %>%
factor(levels= c('cgsb', 'swg_low', 'swg_med', 'swg_hi')) # make it a factor so that it is plotted in the right order in the facets
str(scenario)   

leaching <- vector(mode="numeric", length=0)
 for (i in seq(data_list))
   leaching <- append(leaching, data_list[[i]][,1])
str(leaching)  
area <- vector(mode="numeric", length=0)
 for (i in seq(data_list))
   area <- append(area, data_list[[i]][,2])
str(area)
   
leach <- data.frame(scenario, leaching, area = area*1e-6) # this factor to show Mha

head(leach)
```

Plot the distributions:
```{r histograms, fig.cap="Figure 1: Distributions of NO3 leaching"}

scenarios <- c('cgsb'= "Status Quo (corn/soybeans)", 'swg_low' = "Low yielding switchgrass", 'swg_med' = "Medium yielding switchgrass", 'swg_hi' = "High yielding switchgrass")

ggplot(leach, aes(leaching, weight = area)) + 
  geom_histogram(binwidth=2, alpha = .5, position="identity") +
  theme_b_border() +
  scale_x_continuous(name="Mean NO3 leaching 2006-2015 (kg N/ha)") +
  scale_y_continuous(name="Area (Mha)") +
  theme(legend.position="bottom") +
  facet_wrap( ~ scenario, ncol=2, labeller = as_labeller(scenarios)) 
```

##2. Correlation between profitability and NO3 leaching in corn and soybean fields##

I am using the table `05_dndc_clumu_cgsb_swg` in the isuag database, that contains 2012-2015 mean profit and leaching values for each of the four scenarios on a subfield (clu-map unit) scale. I want to see if there is a correlation between profitability and NO3 leaching, but since the complete dataset contains more than 3 million records, I want to randomly select a subsample for the correlation.


Using a SQL chunk, create a table from a subsample (n=10000) *within* the PostgreSQL database. Setseed is used so that every time I run the code I will get the same random sample.
```{sql, connection=con, message=FALSE, cache=TRUE}
SELECT setseed(0.5)
```
```{sql, connection=con, message=FALSE, cache=TRUE}
DROP TABLE IF EXISTS "r_dndc_clumu_cgsb_swg_sample";
```
```{sql, connection=con, message=FALSE, cache=TRUE}
CREATE TABLE "r_dndc_clumu_cgsb_swg_sample" AS SELECT mean_profit_ha, ave_no3_leach_ha_cgsb FROM "05_dndc_clumu_cgsb_swg" ORDER BY random() LIMIT 10000
```


Pull the new table into R:
```{r data_sample}
sample = tbl(isuag_db, "05_dndc_clumu_cgsb_swg_sample") %>%
  as.data.frame(sample)

head(sample)
str(sample)
```
Plot the sample:
```{r scatterplot, fig.cap="Figure 2: Scatterplot of a subsample (n=10000) of profitability and corn/soy leaching data on subfield areas in Iowa. The red lines indicate possible cut off values, such as -250 US$/ha for profitability (solid) and 100 kg N/ha for NO3 leaching (dashed)."}
ggplot() +
  geom_point(data = sample, aes(x = mean_profit_ha, y = ave_no3_leach_ha_cgsb)) +
  theme_b_border() +
  scale_x_continuous(name="Mean profitability 2012-2015 (US$/ha)") +
  scale_y_continuous(name="Mean NO3 leaching 2006-2015 (kg N/ha)") +
  geom_vline(aes(xintercept= -250, linetype= "dashed", color = "red"),  show.legend = FALSE) +
  geom_hline(aes(yintercept= 100, linetype= "dotted", color = "red"),  show.legend = FALSE) 
  
```
There are many records with leaching values close to 0, and then only a few that are higher but below about 10. The next plot zooms in on hte y axis to see this better:
```{r scatterplot_zoom, fig.cap="Figure 3: Scatterplot of a subsample (n=10000) of profitability and corn/soy leaching data on subfield areas in Iowa. The y axis is zoomed in on 0-20 kg N/ha to better see the low leaching values. The red line indicates a possible cut off value of -250 US$/ha for profitability."}
ggplot() +
  geom_point(data = sample, aes(x = mean_profit_ha, y = ave_no3_leach_ha_cgsb)) +
  theme_b_border() +
  scale_x_continuous(name="Mean profitability 2012-2015 (US$/ha)") +
  scale_y_continuous(name="Mean NO3 leaching 2006-2015 (kg N/ha)", limits=c(0,20)) +
  geom_vline(aes(xintercept= -250, linetype= "dashed", color = "red"),  show.legend = FALSE) +
  geom_hline(aes(yintercept= 100, linetype= "dotted", color = "red"),  show.legend = FALSE) 
  
```
In order to know how much of the area is included in those very low leaching patches, I run queries in the SQL database:
```{sql, connection=con, message=FALSE, cache=TRUE}
SELECT sum(clumuha) FROM "05_dndc_clumu_cgsb_swg" WHERE ave_no3_leach_ha_cgsb < 0.1
```
```{sql, connection=con, message=FALSE, cache=TRUE}
SELECT sum(clumuha) FROM "05_dndc_clumu_cgsb_swg" WHERE ave_no3_leach_ha_cgsb < 0.5
```
```{sql, connection=con, message=FALSE, cache=TRUE}
SELECT sum(clumuha) FROM "05_dndc_clumu_cgsb_swg" WHERE ave_no3_leach_ha_cgsb < 1
```
```{sql, connection=con, message=FALSE, cache=TRUE}
SELECT sum(clumuha) FROM "05_dndc_clumu_cgsb_swg" WHERE ave_no3_leach_ha_cgsb > 1 AND ave_no3_leach_ha_cgsb < 10
```

##3. Switchgrass integration scenarios##

From figure 2 we can see that the relation between NO3 leaching and profitability is not completely random. At higher profitability, the number of subfield patches with high NO3 leaching values decreases. The lower the profitability, the higher the heterogeneity in leaching values. In other words, by managing the areas of lowest profitability in switchgrass would target those areas of highest leaching values (but also many of lower leaching values). Managing the areas of highest leaching (e.g. above a cut off of 100 kg N/ha) would mostly affect the areas that were on average unprofitable between 2012 and 2015.

I am chosing -250 US$/ha as a profitability cut off and 1-- kg N/ha as an NO3 leaching cut off. That means, I produce two switchgrass integration scenarios:

1. Profit-optimized (PO): Switchgrass is grown on the subfield areas where mean profitability is below -250 US$/ha
2. Water quality-optimized (WO): Switchgrass is grown on the subfield areas where NO3 leaching is above 100 kg N/ha

Each of those scenario has three "sub-scenarios" assuming the three different switchgrass yields, so I end up having 6 scenarios that I want to compare to the status quo.

Comparison criteria:

Improvement of total N leaching in form of NO3 state wide and on the county level (in % of status quo values).

Leaching sums are calculated in PostgreSQL. Access the results:
```{r}

```


Shut the database down:
```{r shut, message=FALSE}
rm(list='isuag_db'); gc() 
```
