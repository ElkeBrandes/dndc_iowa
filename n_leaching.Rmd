---
title: "Modelled N loss by NO~3~^-^ leaching and NH~3~ volatilization  in Iowa from row cropped and switchgrass fields"
author: "Elke Brandes"
date: "Tuesday, November 01, 2016"
output: html_document
bibliography: nutrient_bibliography.bib
---
This paper describes the data analysis of N loss results in Iowa. The initial data are the DNDC-outputs from Gabe McNunn on a clu-mapunit scale. I have performed the first analysis steps in the PostgreSQL database and access the resulting tables with the code below (using `dplyr` and `RPostgreSQL`).

##Required packages##
```{r packages, message=FALSE}
library('RPostgreSQL') # PostgreSQL database connection
library("ggplot2") # for the figures
library("maps") # to plot maps, contains country/state/county outlines
library("gridGraphics") # needed for the function unit in ggplot
library("tidyverse") # to make tidy tables, includes dplyr needed for PostgreSQL database connection
library('knitr') # to use kable() function

library(rgdal) # to read in shape files
library(ggmap)
library(scales)
library(RColorBrewer)
library("sp") # to use merge with a spatial data frame

library("tmap")


```


### Connect to the PostgreSQL datbase
With dplyr:
```{r connect_dplyr, message=FALSE}


pw <- "xxxx" # enter password here
isuag_db <- src_postgres(dbname = 'isuag',
                           host = 'isu-ag-db.agsolver.com',
                           port = 5432,
                           user = 'isuag',
                           password = pw)

```
With RPostgreSQL:
```{r, connect_rpostgres, message=FALSE}

drv <- dbDriver("PostgreSQL") # loads the PostgreSQL driver
con <- dbConnect(drv, dbname = "isuag",  # creates a connection to the postgres database
                 host = "isu-ag-db.agsolver.com", port = 5432,
                 user = "isuag", password = pw)
# note that "con" will be used later in each connection to the database
```

### For visualization

I am using a modified theme for ggplot that has a black border and white background:
```{r theme, cache=TRUE}
theme_b_border <- function (base_size = 12, base_family = "") 
{
  theme_grey(base_size = base_size, base_family = base_family) %+replace% 
    theme(
      axis.text = element_text(size = rel(0.8), margin = margin(r=10)), #margin 
      axis.ticks = element_line(colour = "black"),
      axis.ticks.length = unit(0.15, "cm"),
      legend.key = element_rect(colour = NA), panel.background = element_rect(fill = "white", 
      colour = NA), panel.border = element_rect(fill = NA, 
      colour = "black"), panel.grid.major = element_line(colour = NA, 
      size = 0.2), panel.grid.minor = element_line(colour = NA, 
      size = 0.5), strip.background = element_rect(fill = "grey80", 
      colour = "grey50", size = 0.2))
}
```


##1. The baseline: Profitability in corn and soybeans

I am selecting the areas that will be managed in switchgrass based on mean profitability and mean N loss in 2012-2015 in the status quo management.

### State-wide mean profitability distribution

```{r profit_distribution, warning = FALSE, fig.width=4.5, fig.height=3, fig.cap="Figure 1: Distribution of mean profitability 2012-2015. The vertical line marks the -150 US$/ha cut off value used for the switchgrass integration below."}
profit = tbl(isuag_db, "01_profit_mean_2012_2015_aggregated") %>%
  as.data.frame()
profit$sum_ha <- profit$sum_ha * 1e-6  # convert to Mha

ggplot(profit, aes(profit_mean_ha_rounded, weight = sum_ha)) + 
  geom_histogram(binwidth=20, alpha = .5, position="identity") +
  theme_b_border() +
  labs(x=expression(Mean~profitability~2012-2015~("US$"~ha^{-1})),
       y=expression(Area~(Mha))) +
  scale_x_continuous() +
  scale_y_continuous() +
  geom_vline(aes(xintercept= -150, linetype= "dashed"),  show.legend = FALSE) 
```


### Spatial distribution of highly unprofitable areas

I want to see how the areas below -150 US$/ha are distributed accross Iowa. First, I read in a county shapefile. Then, I read in the table containing the county-level unprofitable ha from the PostgreSQL database. In order to join hte data, I need to change the format of the county identifier "fips". I convert "fips" into a factor, then join the spatial and the attribute data on "fips". I then fortify (make a data frame out of) the spatial data frame and assign a column with a serial id. Finally, I join the attribute (unprofitable areas) data to this dataframe.

```{r profit_spatial, message = FALSE, warning = FALSE, cache=TRUE, fig.cap="Figure 2: Areas below a mean 2012-2015 profitability of -150 US$/ha per county. No constraints were made with regards to subfield area size, shape or position."}
counties <- readOGR(dsn="Z:/ElkeBrandes/projects/01 subfield profit/data analysis/02 GIS/government_units/iowa_cnty/IA_cnty/county.shp",layer="county")
names(counties)[9] <- "fips" 

profit_county <- tbl(isuag_db, "07_swg_area_counties_po") %>%
  as.data.frame() 

 for (i in 1:length(profit_county$fips)) {
   profit_county$fips[i] <- sub("IA", "19", profit_county$fips[i])
    }

# profit_county$fips <- as.factor(profit_county$fips)
counties@data <- left_join(counties@data, profit_county, by = "fips")
counties_df <- fortify(counties)
counties$id <- row.names(counties) 
counties_profit_df <- left_join(counties_df, counties@data)

# add a spatial data frame with the county centroids, to be used to plot the total leaching N per county:
centroids <- getSpPPolygonsLabptSlots(counties) %>%
  as.data.frame() 

centroids$id <- as.character(0:98)

# join the total N leaching data to the centroids 
counties_profit_df <- left_join(counties_profit_df, centroids)

# create a theme without axes:
ditch_the_axes <- theme(
  axis.text = element_blank(),
  axis.line = element_blank(),
  axis.ticks = element_blank(),
  panel.border = element_blank(),
  panel.grid = element_blank(),
  axis.title = element_blank()
  )

ggplot() +
  geom_polygon(data = counties_profit_df, aes(long, lat, group = group, fill=area_in_swg_perc), color = "white") +
  geom_point(data = counties_profit_df, aes(V1, V2, size = area_in_swg), color = "orange") +
  labs(size = expression(Total~area~below~-150~"US$"~ha^{-1}~(ha))) +
  coord_equal() +
  ditch_the_axes +
  labs(fill = expression(Relative~area~below~-150~"US$"~ha^{-1}~("%"))) +
  scale_fill_gradient(low = "white", high="dark blue", guide = "colourbar") +
  ggtitle("Highly unprofitable area per county")

```

### County effects?
Figure 2 suggests that NASS reported county yields and/or county survey cash rents are reponsible for strong contrasts between neiboring counties (also seen in the profit distribution on a subfield resolution). Therefore, I calculated 2012-2015 means for corn and soybean yield and cash rent per county in PostgreSQL (query script 09_county_mean_yields_cashrents_2012_2015) to visualize them.
```{r county_yield_rent, cache=TRUE}
counties <- readOGR(dsn="Z:/ElkeBrandes/projects/01 subfield profit/data analysis/02 GIS/government_units/iowa_cnty/IA_cnty/county.shp",layer="county")
names(counties)[9] <- "fips" 

yield_rent_county <- tbl(isuag_db, "09_county_mean_yields_cashrents_2012_2015") %>%
  as.data.frame() 

 for (i in 1:length(yield_rent_county$fips)) {
   yield_rent_county$fips[i] <- sub("IA", "19", yield_rent_county$fips[i])
 }
head(yield_rent_county, n = 2)
counties@data <- left_join(counties@data, yield_rent_county, by = "fips")
#(counties@data, n = 2)
counties_df <- fortify(counties)
str(counties_df)
head(counties_df, n=2)
counties$id <- row.names(counties) 
counties_yield_rent_df <- left_join(counties_df, counties@data)
head(counties_yield_rent_df, n = 2)
```
```{r multiplot, cache=TRUE}
multiplot <- function(..., plotlist = NULL, file, cols = 1, layout = NULL) {
  require(grid)

  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  if (is.null(layout)) {
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                    ncol = cols, nrow = ceiling(numPlots/cols))
  }

  if (numPlots == 1) {
    print(plots[[1]])

  } else {
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    for (i in 1:numPlots) {
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}
```



```{r county_yield_rent_maps, cache=TRUE, fig.show="hold", fig.width=5, fig.height=10, fig.cap="Figure 3: Mean cash rents and yields per county, averaged over 2012-2015."}
m1 <- ggplot() +
  geom_polygon(data = counties_yield_rent_df, aes(long, lat, group = group, fill=cg_yield), color = "white") +
  labs(fill = expression(Mean~maize~yield~(kg~ha^{-1}))) +
  coord_equal() +
  ditch_the_axes +
  scale_fill_gradient(low = "white", high="orange", guide = "colourbar") 

m2 <- ggplot() +
  geom_polygon(data = counties_yield_rent_df, aes(long, lat, group = group, fill=sb_yield), color = "white") +
  labs(fill = expression(Mean~soybean~yield~(kg~ha^{-1}))) +
  coord_equal() +
  ditch_the_axes +
  scale_fill_gradient(low = "white", high="dark green", guide = "colourbar") 

m3 <- ggplot() +
  geom_polygon(data = counties_yield_rent_df, aes(long, lat, group = group, fill=avg_rent_2012_2015), color = "white") +
  labs(fill = expression(Mean~cash~rent~("US$"~ha^{-1}))) +
  coord_equal() +
  ditch_the_axes +
  scale_fill_gradient(low = "white", high="red", guide = "colourbar") 

m4 <- ggplot() +
  geom_polygon(data = counties_yield_rent_df, aes(long, lat, group = group, fill=cg_yield/avg_rent_2012_2015), color = "white") +
  labs(fill = expression(Maize~yield~"/"~cash~rent~(kg~"US$"^{-1}))) +
  coord_equal() +
  ditch_the_axes +
  scale_fill_gradient(low = "white", high="blue", guide = "colourbar") 

multiplot(m1, m2, m3, m4, cols = 1)
```

```{r yield_rent_ratio}
ggplot() +
  geom_polygon(data = counties_yield_rent_df, aes(long, lat, group = group, fill=cg_yield/avg_rent_2012_2015), color = "white") +
  labs(fill = expression(Corn~yield~"/"~cash~rent~(kg~"US$"^{-1}))) +
  coord_equal() +
  ditch_the_axes +
  scale_fill_gradient(low = "white", high="blue", guide = "colourbar") +
  ggtitle("Ratio of corn yield to cash rent,\nusing 2012-2015 means of NASS reported yields\nand ISU cash rent survey results")
```


##2. Distributions of N loss in Iowa, from row cropped and switchgrass fields##

Connect to the isuag database and load tables that contain the rounded average N loss values (in kg/ha) for the **four scenarios**:

1. Status quo (row cropped areas in corn or soybean as is from 2012-2015)
2. Switchgrass low yield (all areas that were continuously in corn/soy from 2012-2015 were planted to switchgrass in 2006 for 10 years, assuming switchgrass yield is 7000 kg/ha)
3. Switchgrass medium yield (assuming a yield of 10000 kg/ha)
4. Switchgrass high yield (assuming a yield of 12500 kg/ha)

The N loss values and respective patch areas were aggregated to the same N loss values, and for each scenario, one table was created.

Use the dplyr PostgreSQL handle into the database and create a data frame:
```{r fetch_distr, cache=TRUE}

cgsb_leach <-tbl(isuag_db, "06_cgsb_ave_n_loss_rounded_aggr")  %>%
  as.data.frame()
swg_low <-tbl(isuag_db, "06_swg_7500_ave_n_loss_rounded_aggr")  %>%
  as.data.frame()
swg_med <-tbl(isuag_db, "06_swg_10000_ave_n_loss_rounded_aggr")  %>%
  as.data.frame()
swg_hi <-tbl(isuag_db, "06_swg_12500_ave_n_loss_rounded_aggr")  %>%
  as.data.frame()
```

I can run some test here:
```{r test_distr}
# send a query through dplyr
query = "SELECT SUM(area_ha) FROM \"06_cgsb_ave_n_loss_rounded_aggr\" WHERE ave_n_loss_cgsb_round > 60"
sum = tbl(isuag_db, sql(query))
sum
```

Create a list of data frames:
```{r list}
data_list <- list(cgsb_leach, swg_low, swg_med, swg_hi)
str(data_list[[1]])
```

Prepare a data frame to be used for the NO~3~ leaching facet plot:
```{r data, message=FALSE, cache=TRUE}
scenario <- c(rep("cgsb", sum(sapply(data_list[1],nrow))), rep("swg_low", sum(sapply(data_list[2],nrow))), rep("swg_med", sum(sapply(data_list[3],nrow))), rep("swg_hi", sum(sapply(data_list[4],nrow)))) %>%
factor(levels= c('cgsb', 'swg_low', 'swg_med', 'swg_hi')) # make it a factor so that it is plotted in the right order in the facets

leaching <- vector(mode="numeric", length=0)
 for (i in seq(data_list))
   leaching <- append(leaching, data_list[[i]][,1])
str(leaching)  
area <- vector(mode="numeric", length=0)
 for (i in seq(data_list))
   area <- append(area, data_list[[i]][,2])
   
leach <- data.frame(scenario, leaching, area = area*1e-6) # this factor to show Mha
```

Plot the distributions:
```{r histograms, cache=TRUE, warning=FALSE, fig.cap="Figure 3: Distributions of N loss in Iowa. Values were averaged over the mananagement horizon of 10 years, including two establishment years."}
scenarios <- c('cgsb'= "Status Quo (corn/soybeans)", 'swg_low' = "Low yielding switchgrass", 'swg_med' = "Medium yielding switchgrass", 'swg_hi' = "High yielding switchgrass")

ggplot(leach, aes(leaching, weight = area)) + 
  geom_histogram(binwidth=2, alpha = .5, position="identity") +
  theme_b_border() +
  labs(x=expression(Mean~NO[3]^{"-"}~leaching~"+"~NH[3]~volatilization~2006-2015~(kg~N~ha^{-1})),
       y=expression(Area~(Mha))) +
  scale_x_continuous() +
  scale_y_continuous() +
  theme(legend.position="bottom") +
  facet_wrap( ~ scenario, ncol=2, labeller = as_labeller(scenarios)) 
```

##3. Correlation between profitability and NO~3~^-^ leaching in corn and soybean fields
In this chapter, I am only looking at the N loss through NO~3~^-^ leaching to check wether the numbers are reasonable.
I am using the table `05_dndc_clumu_cgsb_swg` in the isuag database, that contains 2012-2015 mean profit and leaching values for each of the four scenarios on a subfield (clu-map unit) scale. I want to see if there is a correlation between profitability and NO3 leaching, but since the complete data set contains more than 3 million records, I want to randomly select a sub-sample for the correlation.

Using a SQL chunk, I create a table from a sub-sample (n=10,000) *within* the PostgreSQL database. Setseed is used so that every time I run the code I will get the same random sample.
```{sql, connection=con, message=FALSE, cache=TRUE, include=FALSE}
SELECT setseed(0.5)
```
```{sql, connection=con, message=FALSE, cache=TRUE}
DROP TABLE IF EXISTS "r_dndc_clumu_cgsb_swg_sample";
```
```{sql, connection=con, message=FALSE, cache=TRUE}
CREATE TABLE "r_dndc_clumu_cgsb_swg_sample" AS SELECT mean_profit_ha, ave_no3_leach_ha_cgsb FROM "05_dndc_clumu_cgsb_swg" ORDER BY random() LIMIT 10000
```


Pull the new table into R:
```{r data_sample}
sample = tbl(isuag_db, "r_dndc_clumu_cgsb_swg_sample") %>%
  as.data.frame(sample)

head(sample, n=2)
str(sample)
```

I plot the sample as a scatter plot:
```{r scatterplot, warning=FALSE, cache=TRUE, fig.width=4.5, fig.height=3, fig.cap="Figure 4: Scatterplot of a subsample (n=10,000) of profitability and corn/soy leaching data on subfield areas in Iowa. The red lines indicate possible cut off values, such as -150 US$ ha^-1^ for profitability (solid) and 60 kg N ha^-1^ for NO3 leaching (dashed)."}
ggplot() +
  geom_point(data = sample, aes(x = mean_profit_ha, y = ave_no3_leach_ha_cgsb)) +
  theme_b_border() +
  labs(y=expression(Mean~NO[3]^{"-"}~leaching~2006-2015~(kg~N~ha^{-1})),
       x=expression(Mean~profitability~2012-2015~("US$"~ha^{-1}))) +
  geom_vline(aes(xintercept= -150, linetype= "dashed", color = "red"),  show.legend = FALSE) +
  geom_hline(aes(yintercept= 60, linetype= "dotted", color = "red"),  show.legend = FALSE)
  
```
### Areas with very low NO~3~^-^ leaching

There are many records with leaching values close to 0, and then only a few that are higher but below about 10. The next plot zooms in on the y axis to see this better:
```{r scatterplot_zoom, warning = FALSE, cache=TRUE, fig.width=4.5, fig.height=3, fig.cap="Figure 5: Scatterplot of a subsample (n=10000) of profitability and corn/soy leaching data on subfield areas in Iowa. The y axis is zoomed in on 0-20 kg N ha^-1^ to better see the low leaching values. The red line indicates a possible cut off value of -150 US$ ha^-1^ for profitability."}
ggplot() +
  geom_point(data = sample, aes(x = mean_profit_ha, y = ave_no3_leach_ha_cgsb)) +
  theme_b_border() +
  labs(y=expression(Mean~NO[3]^{"-"}~leaching~2006-2015~(kg~N~ha^{-1})),
       x=expression(Mean~profitability~2012-2015~("US$"~ha^{-1}))) +
  scale_x_continuous() +
  scale_y_continuous(limits=c(0,20)) +
  geom_vline(aes(xintercept= -150, linetype= "dashed", color = "red"),  show.legend = FALSE)
  
```
In order to know how much of the area is included in those very low leaching patches, I run queries in the SQL database:
```{sql, connection=con, message=FALSE, cache=TRUE}
SELECT sum(clumuha) FROM "05_dndc_clumu_cgsb_swg" WHERE ave_no3_leach_ha_cgsb < 0.1
```
```{sql, connection=con, message=FALSE, cache=TRUE}
SELECT sum(clumuha) FROM "05_dndc_clumu_cgsb_swg" WHERE ave_no3_leach_ha_cgsb < 0.5
```
```{sql, connection=con, message=FALSE, cache=TRUE}
SELECT sum(clumuha) FROM "05_dndc_clumu_cgsb_swg" WHERE ave_no3_leach_ha_cgsb < 1
```
```{sql, connection=con, message=FALSE, cache=TRUE}
SELECT sum(clumuha) FROM "05_dndc_clumu_cgsb_swg" WHERE ave_no3_leach_ha_cgsb > 1 AND ave_no3_leach_ha_cgsb < 10
```

### Soil properties on low leaching areas

I looked into the soil properties of those low leaching areas. For this, I queried the SSURGO database through the [SQL interface](http://sdmdataaccess.nrcs.usda.gov/Query.aspx) to get data on total sand fraction and pH per component and horizon. I imported the table into the isuag PostgreSQL database and joined the soil data (total sand fraction and pH), aggregated to the mapunit, to the DNDC results. 

I then drew random samples from that table to analyze the relationship between leaching and sand fraction / pH.
In high pH soils the equilibrium between NH~3~^+^ and NH~3~ is shifted toward NH~3~, therefore they might show higher volatilization and lower NO~3~^-^ leaching, because the equilibrium is calculated before the nitrification to NO~3~^-^ and subsequent leaching in the DNDC model. Higher sand fraction means lower CEC (cation exchange capacity), therefore more NH~3~^+^ is available (not sorbed by negatively charged colloids).

```{sql, connection=con, message=FALSE, cache=TRUE, include=FALSE}
SELECT setseed(0.5)
```
```{sql, connection=con, message=FALSE, cache=TRUE}
DROP TABLE IF EXISTS "05_leaching_soil_sample";
```
```{sql, connection=con, message=FALSE, cache=TRUE}
CREATE TABLE "05_leaching_soil_sample" AS SELECT ave_no3_leach_ha_cgsb, avg_sandtotal_r, avg_ph1to1h2o_r, avg_ph01mcacl2_r FROM "05_leaching_soil" ORDER BY random() LIMIT 10000
```


I make a dataframe out of the db table:
```{r soil_sample}
soil = tbl(isuag_db, "05_leaching_soil_sample") %>%
  as.data.frame()
head(soil, n=2)
```

Then I plot the sample:
```{r scatter_leach_sand, warning=FALSE, fig.width=4.5, fig.height=3, fig.show = "hold", fig.cap="Figure 6: Scatterplot of a subsample (n=10,000) of corn/soy leaching data and sand fraction on subfield areas in Iowa."}
ggplot() +
  geom_point(data = soil, aes(x = avg_sandtotal_r, y = ave_no3_leach_ha_cgsb)) +
  theme_b_border() +
  scale_x_continuous() +
  scale_y_continuous() +
  labs(y=expression(Mean~NO[3]^{"-"}~leaching~2006-2015~(kg~N~ha^{-1})),
       x=expression(Sand~fraction~("%")))

ggplot() +
  geom_point(data = soil, aes(x = avg_sandtotal_r, y = ave_no3_leach_ha_cgsb)) +
  theme_b_border() +
  scale_x_continuous() +
  scale_y_continuous(limits=c(0,20)) +
  labs(y=expression(Mean~NO[3]^{"-"}~leaching~2006-2015~(kg~N~ha^{-1})),
       x=expression(Sand~fraction~("%")))
  
ggplot() +
  geom_point(data = soil, aes(x = avg_ph1to1h2o_r, y = ave_no3_leach_ha_cgsb)) +
  theme_b_border() +
  scale_x_continuous() +
  scale_y_continuous() +
  labs(y=expression(Mean~NO[3]^{"-"}~leaching~2006-2015~(kg~N~ha^{-1})),
       x=expression(pH))

ggplot() +
  geom_point(data = soil, aes(x = avg_ph1to1h2o_r, y = ave_no3_leach_ha_cgsb)) +
  theme_b_border() +
  scale_x_continuous() +
  scale_y_continuous(limits=c(0,20)) +
  labs(y=expression(Mean~NO[3]^{"-"}~leaching~2006-2015~(kg~N~ha^{-1})),
       x=expression(pH))
```

```{r scatter_ph, fig.width=4.5, fig.height=3, warning=FALSE, fig.cap="Figure 7: Scatterplot of a subsample (n=10,000) of pH values measured with different methods from the SSURGO database."}
ggplot() +
  geom_point(data = soil, aes(x = avg_ph1to1h2o_r, y = avg_ph01mcacl2_r)) +
  theme_b_border() +
  scale_x_continuous() +
  scale_y_continuous() +
  labs(y=expression(pH~CaCl2), x=expression(pH~H2O)) +
  geom_abline(intercept=0, slope = 1)


```

Figure 6 shows that the low leaching values do not fall out of the general pattern. Soils with lower sand fraction generally show lower leaching, but the very low leaching soils show a range of sand fraction. There is a cluster of low leaching subfield areas of pH 7.9 - 8.1. For these soils, NO~3~^-^ leaching might be low because the NH~3~ <-> NH~4~^+^ equilibrium is shifted toward the volatile NH~3~ that is leaving the soil.

To eliminate artifacts that are caused by model structure and mechansim, we decided to sum up NO~3~^-^ leaching and NH~3~ volatilization, assuming that volatilization is negligible since it is minimized by management (i.e. timing of fertilization before rain events, injecting anhydrous ammonia below the surface). Estimated N losses due to NH~3~ volatilization from synthetic fertilizers range between 0 and 5 kg ha^-1^ in the USA, not including the use of inhibiting chemicals [@bouwman2002nh3].

##4. N loss through NO~3~^-^ leaching and NH~3~ volatilization

I calculated N losses as a sum of the model outputs NO~3~^-^ leaching and NH~3~ volatilization in PostgreSQL for corn/soybean and for the three switchgrass yield scenarios.

### Correlation between NO~3~^-^ leaching and NH~3~ volatilization

I draw a sample from the original DNDC result table for the status quo to look at the relationship between the two N loss pools. Note: I am not transforming the values into metric units in this case, so the units are lbs/acre.

```{sql, connection=con, message=FALSE, cache=TRUE, include=FALSE}
SELECT setseed(0.5)
```
```{sql, connection=con, message=FALSE, cache=TRUE}
DROP TABLE IF EXISTS "r_isu_cgsb_clumu_proc_sample";
```
```{sql, connection=con, message=FALSE, cache=TRUE}
CREATE TABLE "r_isu_cgsb_clumu_proc_sample" AS SELECT ave_no3_leach, ave_nh3_vol FROM isu_cgsb_clumu_proc ORDER BY random() LIMIT 10000
```


Pull the new table into R:
```{r leach_vol_sample}
sample = tbl(isuag_db, "r_isu_cgsb_clumu_proc_sample") %>%
  as.data.frame(sample)

head(sample, n=2)
str(sample)
```

I plot the sample as a scatter plot:
```{r leach_vol_scatterplot, warning=FALSE, cache=TRUE, fig.width=4.5, fig.height=3, fig.cap="Figure 4: Scatterplot of a subsample (n=10,000) of corn/soy NO~3~^-^ leaching and NH~3~ volatilization data on subfield areas in Iowa."}
ggplot() +
  geom_point(data = sample, aes(x = ave_no3_leach, y = ave_nh3_vol)) +
  theme_b_border() +
  labs(x=expression(Mean~NO[3]^{"-"}~leaching~2006-2015~(lbs~N~acre^{-1})),
       y=expression(Mean~NH[3]~volatilization~2006-2015~(lbs~N~acre^{-1})))
  
```


### Correlation between profitability and N loss in corn and soybean fields

I am using the table `05_dndc_clumu_cgsb_swg_n_loss` in the isuag database, that contains 2012-2015 mean profit and N loss values for each of the four scenarios on a subfield (clu-map unit) scale. I want to see if there is a correlation between profitability and N loss, and if the artifact of low leaching patches seen in Figure 4. disappears as the high NH~3~ volatilization compensates the low NO~3~^-^ leaching.

Using a SQL chunk, I create a table from a sub-sample (n=10,000) *within* the PostgreSQL database. Setseed is used so that every time I run the code I will get the same random sample.
```{sql, connection=con, message=FALSE, cache=TRUE, include=FALSE}
SELECT setseed(0.5)
```
```{sql, connection=con, message=FALSE, cache=TRUE}
DROP TABLE IF EXISTS "r_dndc_clumu_cgsb_swg_n_loss_sample";
```
```{sql, connection=con, message=FALSE, cache=TRUE}
CREATE TABLE "r_dndc_clumu_cgsb_swg_n_loss_sample" AS SELECT mean_profit_ha, ave_n_loss_ha_cgsb FROM "05_dndc_clumu_cgsb_swg_n_loss" ORDER BY random() LIMIT 10000
```


Pull the new table into R:
```{r data_sample_n_loss}
sample = tbl(isuag_db, "r_dndc_clumu_cgsb_swg_n_loss_sample") %>%
  as.data.frame(sample)

```

I visualize the sample as a scatter plot:
```{r scatterplot_n_loss, warning=FALSE, fig.cap="Figure 8: Scatterplot of a subsample (n=10,000) of profitability and corn/soy N loss data on subfield areas in Iowa. The red lines indicate possible cut off values, such as -150 US$ ha^-1^ for profitability (solid) and 60 kg N ha^-1^ for N loss (dashed)."}
ggplot() +
  geom_point(data = sample, aes(x = mean_profit_ha, y = ave_n_loss_ha_cgsb)) +
  theme_b_border() +
  labs(y=expression(Mean~N~loss~2006-2015~(kg~N~ha^{-1})),
       x=expression(Mean~profitability~2012-2015~("US$"~ha^{-1}))) +
  geom_vline(aes(xintercept= -150, linetype= "dashed", color = "red"),  show.legend = FALSE) +
  geom_hline(aes(yintercept= 60, linetype= "dotted", color = "red"),  show.legend = FALSE)
  
```

##5. Switchgrass integration scenarios

From figure 8 we can see that the relation between N loss and profitability is not completely random. At higher profitability, the number of sub-field patches with high N loss values decreases. The lower the profitability, the higher the variability in N loss values. In other words, managing the areas of lowest profitability in switchgrass would target those areas of highest N loss values (but also many of lower leaching values). Managing the areas of highest N loss (e.g. above a cut off of 60 kg N/ha) would affect unprofitable as well as unprofitable areas.

Therefore, we decided in a team discussion to target those areas that fall in the upper left quarter of the graph divided by the two red lines: Subfield areas with a profitability below -150 US$/ha and N loss > 60 kg N/ha. 

Comparison criteria:

Improvement of total N loss in form of NO~3~^-^ and NH~3~ state-wide and on the county level (in % of status quo values).

Total state-wide N loss sums were calculated in PostgreSQL. Access the results:
```{r total_leaching}
n_loss_tot <-tbl(isuag_db, "05_dndc_n_loss_sums_iowa_scenarios")  %>%
  as.data.frame()
n_loss_tot <-   data.frame(value = "total N loss", 
                           n_loss_tot)
head(n_loss_tot)  
names(n_loss_tot) <- c(" ", "Status Quo", "7500", "10000", "12500")

n_loss_red <- data.frame(value = "Reduction (%)", 
                         status_quo = 0,
                        "7500" = (n_loss_tot[1,2]-n_loss_tot[1,3])*100/n_loss_tot[1,2],
                        "10000" = (n_loss_tot[1,2]-n_loss_tot[1,4])*100/n_loss_tot[1,2],
                        "12500" = (n_loss_tot[1,2]-n_loss_tot[1,5])*100/n_loss_tot[1,2])
names(n_loss_red) <- c(" ", "Status Quo", "7500", "10000", "12500")

n_loss_table <- rbind(n_loss_tot[1,],n_loss_red[1,])

kable(n_loss_table, digits = 2, col.names=c(" ", "Status Quo","7500", "10000", "12500"), caption="Table 1: Annual N loss (Million Mg N) in Iowa modelled with DNDC under different switchgrass yield scenarios." )

```

### Total area in switchgrass as a function of profitability and N loss threshold selection

I want to select the total area of polygons that fall under changing profitability and N loss thresholds.

```{r swg_areas, cache=TRUE}
swg_areas <- vector(mode="numeric", length=0)
profit_cutoffs <- c(-1000, -500, -400, -250, -150, 0, 250, 500)
n_loss_cutoffs <- c(0, 20, 40, 50, 60, 80, 100, 200)

# make a cartesian product of the two vectors first:

# function (from https://www.r-bloggers.com/nested-loops-with-mapply/)
CartProduct = function(vector_1, vector_2)
{
 
  if (length(dim(vector_2)) != 0 )
  {
    warning("New vector has more than one dimension.")
    return (NULL)
  }
 
  if (length(dim(vector_1)) == 0)
  {
    CurrentRows = length(vector_1)
    vector_1 = as.matrix(vector_1, nrow = CurrentRows, ncol = 1)
  } else {
    CurrentRows = nrow(vector_1)
  }
 
  var1 = replicate(length(vector_2), vector_1, simplify=F)
  var1 = do.call("rbind", var1)
 
  var2 = rep(vector_2, CurrentRows)
  var2 = matrix(var2[order(var2)], nrow = length(var2), ncol = 1)
 
  CartProduct = cbind(var1, var2)
  return (CartProduct)
}

comb <- CartProduct(profit_cutoffs, n_loss_cutoffs)

# write a function that uses each of the combinations, using the matrix returned from the function CartProduct:


# for (i in 1:length(profit_cutoffs)) {
#     query <- paste("SELECT SUM(clumuha) FROM \"05_dndc_clumu_cgsb_swg_n_loss\" WHERE mean_profit_ha < ", as.character(profit_cutoffs[i]), "AND ave_n_loss_ha_cgsb > 60")
#     sum_area <- tbl(isuag_db, sql(query)) %>%
#       as.data.frame()
#     sum_area <- sum_area[1,1]
#     swg_areas <- append(swg_areas, sum_area)
# }

area_select <- function(cutoff_1, cutoff_2)
{ query <- paste("SELECT SUM(clumuha) FROM \"05_dndc_clumu_cgsb_swg_n_loss\" WHERE mean_profit_ha < ", as.character(cutoff_1), "AND ave_n_loss_ha_cgsb > ", as.character(cutoff_2))
    sum_area <- tbl(isuag_db, sql(query)) %>%
      as.data.frame()
    sum_area <- sum_area[1,1]
    return(sum_area)
}

# apply the function to each value in the matrix

swg_areas <- mapply(area_select, comb[,1], comb[,2])
comb[,1]

```

```{r no3_leaching_sums, cache=TRUE}
sum_n_loss <- tbl(isuag_db, "08_dndc_n_loss_sums_iowa_dispr_benefits") %>%
  as.data.frame() %>%
  gather(corn_soybeans, swg_7500_1, swg_7500_2, swg_7500_3, swg_7500_4, swg_7500_5, swg_7500_6, swg_7500_7, swg_7500_8, swg_7500_9, swg_7500_10, swg_7500_11, swg_10000_1, swg_10000_2, swg_10000_3, swg_10000_4, swg_10000_5, swg_10000_6, swg_10000_7, swg_10000_8, swg_10000_9, swg_10000_10, swg_10000_11, swg_12500_1, swg_12500_2, swg_12500_3, swg_12500_4, swg_12500_5, swg_12500_6, swg_12500_7, swg_12500_8, swg_12500_9, swg_12500_10, swg_12500_11, key = swg_scenarios, value=ave_n_loss)
```
I calculate the total area in corn/soybean in Iowa to use this number to calculate % area below.
```{sql connection=con, message=FALSE, cache=TRUE}
select sum(clumuha) from "05_dndc_clumu_cgsb_swg_n_loss";
```


I create data frames for the figure:
```{r data_dispr_benefits}
swg_yield <- as.factor(c("NA",rep("7500",11), rep("10000",11),rep("12500",11)))
profit_cutoff <- c(NA, rep(profit_cutoffs,3))
swg_area <- c(0,rep(swg_areas,3))
swg_area_percent <- (swg_area/9374363)*100
N_loss <- sum_n_loss[,2]
N_reduction <- abs((N_loss - N_loss[1])/N_loss[1])*100

relation <- data.frame(swg_yield, profit_cutoff, swg_area_percent, N_reduction)
```

I plot the relationsship between profitability threshold and % area in switchgrass:
```{r thresholds, warning=FALSE, fig.show="hold", fig.height= 3, fig.width=4.5, fig.cap="Figure 6: Relation between the set thresholds in the profitability (left panel) and water quality optimized (right panel) scenario and the resulting area in switchgrass. N loss cut off is constant at 60 kg ha^-1^."}
ggplot() +
  geom_point(data = relation, aes(x = profit_cutoff, y = swg_area_percent)) +
  theme_b_border() +
  labs(x=expression(Profitability~threshold~("US$"~ha^{-1})),
       y=expression(Area~"in"~switchgrass~("%"))) +
  scale_x_continuous(breaks=seq(from=-500, to=200, by= 100)) +
  scale_y_continuous(limits= c(0,65)) +
    geom_vline(aes(xintercept= -150, linetype= "dotted", color = "red"),  show.legend = FALSE)

```

##4. Disproportionate benefits?

I want to see how N loss reduction increases with increasing area in switchgrass, to test if the disproportionate benefits hypothesis holds true in our model.

I plot the state-wide relative N loss reduction from the status quo to switchgrass integration, as a function of the area converted to switchgrass, and as a function of the profitability threshold applied.

```{r relations, cache=TRUE, warning=FALSE, fig.show="hold", fig.height= 3, fig.width=4.5, fig.cap="Figure 7: N loss reduction as a function of area in switchgrass (left panel), and of profitability threshold (right panel)."}

ggplot() +
  geom_point(data = relation, aes(x = swg_area_percent, y = N_reduction, color=swg_yield)) +
  theme_b_border() +
  labs(x=expression(Area~"in"~switchgrass~("%")),
       y=expression(N~loss~reduction~("%"~N))) +
  scale_x_continuous() +
  scale_y_continuous() +
  scale_color_discrete(name="Switchgrass\nYield (kg/ha)",  guide = FALSE)

ggplot() +
  geom_point(data = relation, aes(x = profit_cutoff, y = N_reduction, color=swg_yield)) +
  theme_b_border() +
  labs(x=expression(Profitability~threshold~("US$"~ha^{-1})),
       y=expression(N~loss~reduction~("%"~N))) +
  scale_x_continuous(breaks=seq(from=-500, to=200, by= 100)) +
  scale_y_continuous() +
  scale_color_discrete(name="Switchgrass\nYield") +
  theme(legend.position=c(0.2,0.7))
```

##5. Spatial distribution of N loss changes

I read in the table from the isuag database that contains county identifiers ("fips") and leaching results. 
```{r counties_attributes}
 counties_n_loss = tbl(isuag_db, "07_n_loss_counties") %>%
   as.data.frame()
 # change the data in the column named "FIPS", so that is contains the county identifiers in the same format as the spatial file:
 for (i in 1:length(counties_n_loss$fips)) {
   counties_n_loss$fips[i] <- sub("IA", "19", counties_n_loss$fips[i])
    }
 # make it a factor
  counties_n_loss$fips <- as.factor(counties_n_loss$fips)
```

Read in a shape file with county delineations. I could use a map provided in the maps package or read in a file from my directory, which I do in this case:
```{r counties_spatial, message = FALSE, cache=TRUE}

counties <- readOGR(dsn="Z:/ElkeBrandes/projects/01 subfield profit/data analysis/02 GIS/government_units/iowa_cnty/IA_cnty/county.shp",layer="county")

names(counties)[9] <- "fips" # change to lower case so that we can join on this field later on

head(counties@data, n=2) # shows only the slot "data"
head(counties@polygons[[1]]@Polygons[[1]]@coords, 2) # shows the coordinates

# join the attribute data with the spatial data, using a left join and the identifier "fips":
counties@data <- left_join(counties@data, counties_n_loss, by = "fips")
```
I can map the attributes using tmap, but I want to use ggplot. Therefore I am not using the following code:
```qtm(counties, "ave_n_o3_leach_loss_cgsb")```

To plot spatial data in ggplot, however, I need to make a data frame out of the SpatialPolygonDataFrame to get access to the longitude and latitude. This data frame contains a row for each vertex that the polygons are made of, and an ID starting with 0 up to 98. The attribute data will be lost in this data frame. Therefore, it needs to be joined back afterwards.
```{r join} 
counties_df <- fortify(counties)
head(counties_df, n = 2)
counties$id <- row.names(counties) # assign a column with the variable ID that is equal to the row names (=numbers), starting with 0.
head(counties@data, n = 2)
# join the attributes back to the data frame, to create a dataframe used to map the baseline (corn/soybean):
counties_baseline_df <- left_join(counties_df, counties@data)
```

```{r plot_baseline_map, warning=FALSE, message=FALSE, fig.height=4, fig.cap="Figure 8: County mean annual N loss, averaged over 2012-2015, from corn and soybean fields in Iowa, are shown as a color scale. Bubbles indicate the total N that has been lost on average per year from each county."} 

# create a theme without axes:
ditch_the_axes <- theme(
  axis.text = element_blank(),
  axis.line = element_blank(),
  axis.ticks = element_blank(),
  panel.border = element_blank(),
  panel.grid = element_blank(),
  axis.title = element_blank()
  )

# add a spatial data frame with the county centroids, to be used to plot the total leaching N per county:
centroids <- getSpPPolygonsLabptSlots(counties) %>%
  as.data.frame() 
centroids$id <- as.character(0:98)

# join the total N leaching data to the centroids 
counties_baseline_df <- left_join(counties_baseline_df, centroids)


ggplot() +
  geom_polygon(data = counties_baseline_df, aes(long, lat, group = group, fill=ave_n_loss_cgsb), color = "white") +
  geom_point(data = counties_baseline_df, aes(V1, V2, size = tot_ave_n_loss_cgsb), color = "yellow") +
  labs(size = expression(Total~N~loss~(Mg~N~ha^{-1}))) +
  coord_equal() +
  ditch_the_axes +
  labs(fill = expression(Average~N~loss~(kg~N~ha^{-1}))) +
  scale_fill_gradient(low = "white", high="#009E73", guide = "colourbar") +
  ggtitle("Average and total annual N loss per county")
```

Now, I want to plot three maps in a facet plot that show the N loss results and the loss reduction, when switchgrass is grown on areas losing > 150 US$/ha and losing > 60 kg N/ha when in row crops for each of the three yield scenarios. For the facet plot in ggplot, I need to re-arrange the data, creating the variable "scenario" and adding two columns with values, one for the average leaching and one for the percent change from the baseline to the switchgrass integration scenario.
```{r plot_n_loss_maps,fig.width=10, fig.height=3, fig.cap="Figure 9: County mean annual N loss, averaged over 2012-2015, from three switchgrass integration scenarios in Iowa, are shown as a color scale. Bubbles indicate the total N that has been leaching on average per year from each county. Switchgrass was planted on areas that lost > 150 US$/ha on average between 2012 and 2015 and that lost > 60 kg N/ha. The three maps refer to different yield assumptions for switchgrass (low yielding: 7,500 kg/ha, medium yielding: 10,000 kg/ha, and high yielding: 12,500 kg/ha)"}
# set up the data frame 
counties_swg <- data.frame(id = rep(counties$id,3),
                         scenario = c(rep("swg_7500", length(counties$id)), rep("swg_10000", length(counties$id)), 
                                                                               rep("swg_12500", length(counties))),
                         tot_n_loss = c(counties$tot_ave_n_loss_7500, counties$tot_ave_n_loss_10000,
                                           counties$tot_ave_n_loss_12500),
                         ave_n_loss = c(counties$ave_n_loss_7500, counties$ave_n_loss_10000, counties$ave_n_loss_12500),
                         loss_red = c(counties$n_loss_change_7500, counties$n_loss_change_10000,
                                       counties$n_loss_change_12500))

counties_swg$scenario <- factor(counties_swg$scenario, levels = c("swg_7500", "swg_10000", "swg_12500"))
head(counties_swg, n = 2)
# join data frame with the data frame extracted out of the spatial data frame
counties_swg_df <- left_join(counties_df, counties_swg) %>%
  left_join(centroids)
head(counties_swg_df, n = 4)

# plot the data

swg_yield <- c('swg_7500' = "Low yielding switchgrass", 'swg_10000' = "Medium yielding switchgrass", 'swg_12500' = "High yielding switchgrass")

ggplot(counties_swg_df) +
  geom_polygon(aes(long, lat, group = group, fill=ave_n_loss), color = "white") +
  scale_fill_gradient(low = "white", high="#009E73", guide = "colourbar") +  
  labs(fill = expression(Average~N~loss~(kg~N~ha^{-1}))) +  
  geom_point(aes(V1, V2, size = tot_n_loss), color = "yellow") +
  labs(size = expression(Total~N~loss~(Mg~N))) +
  scale_size(range = c(0, 4)) +
  coord_equal() +
  ditch_the_axes +
  facet_wrap( ~ scenario, ncol = 3, labeller = as_labeller(swg_yield)) +
  ggtitle("Average and total annual N loss per county")
```
From figure 7 and 9, it becomes obvious that, at the switchgrass area fraction we are interested in (around 10% of current cropland), the switchgrass yields do not alter the N loss outcome in a significant way. Therefore, in the following analysis, I only consider the medium yielding scenario (10,000 Mg ha^-1^).
```{r plot_n_loss_reduction_maps, fig.show = "hold", fig.width=4.5, fig.height=3, fig.cap = "Figure 10, left panel: county mean annual N loss, averaged over 2012-2015; right panel: reduction in total N loss in the switchgrass integration scenarios, as % of the status quo losses shown in Figure 8. "}

counties_swg_med_df <- filter(counties_swg_df, scenario == "swg_10000")

ggplot(counties_swg_med_df) +
  geom_polygon(aes(long, lat, group = group, fill=ave_n_loss), color = "white") +
  scale_fill_gradient(low = "white", high="#009E73", guide = "colourbar") +  
  labs(fill = expression(Average~N~loss~(kg~N~ha^{-1}))) +  
  geom_point(aes(V1, V2, size = tot_n_loss), color = "yellow") +
  labs(size = expression(Total~N~loss~(Mg~N))) +
  scale_size(range = c(0, 4)) +
  coord_equal() +
  ditch_the_axes

ggplot(counties_swg_med_df) +
  geom_polygon(aes(long, lat, group = group, fill=loss_red), color = "white") +
  scale_fill_gradient(low = "white", high="#0072B2", guide = "colourbar") +  
  coord_equal() +
  ditch_the_axes +
  labs(fill = expression(N_loss~reduction~("%")))

```


```{r shut, message=FALSE, include=FALSE}
 rm(list='isuag_db'); gc() 
```
